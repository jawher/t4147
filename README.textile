h1. t4147 : a not so mutable TreeSet integration

In Scala there are two family of collections: mutable and immutable ones. When you operate on a mutable collection, you change it in place. On the other hand, an immutable collection doesn't change, it returns a new collection with the update you asked for. Right now, Scala library provides an immutable TreeSet but not his mutable counterpart, let's do it ...

h2. Essential choices
* Since I intend to write a tree based set, it would be a shame to not implement a sorted set since it's the good thing about trees. 
* I'm really interested in exploring assets and liabilities of immutable data structure. So although the API is exposing a mutable collection. The underlying tree will be immutable. Mutability will be obtained by just replacing reference to it.
* AVL tree gets my preference since it's an efficient and elegant kind of balanced and sorted tree.

h2. Implementation

Implementation is highly driven by the Scala base trait you use. It will determine what operations need to be implemented. Nevertheless some operations need to be overridden in order to improve performance.

h3. Pluging into the Scala collection hierarchy

In Scala a trait suffixed by 'Like' holds implementation whereas his counterpart has a structural role.

As said above we are implementing a Set that sorts elements it contains, so not only we have to mix-in from Set and SetLike but also from SortedSet and SortedSetLike.

Here is the definition of TreeSet from a type point of view :

bc. class TreeSet[A](implicit val ordering: Ordering[A]) extends SortedSet[A] with SortedSetLike[A, TreeSet[A]]
  with Set[A] with SetLike[A, TreeSet[A]]  { ... }

Since TreeSet sorts his elements you need to provide him an object responsible for defining the order relation beetween all elements of type A. This why TreeSet primary constructors require an Ordering over A.

h3. AVL Tree

An AVL tree is both a binary and a balanced tree. An AVL is said balanced if for any node, the depth difference beetween left sub-tree and right sub-tree is stricty beetween -2 and 2. It allows insertion, removal and presence test in logarithmic time. Please check dedicated "Wikipedia":http://en.wikipedia.org/wiki/AVL_tree page for more information.

h3. Iterator

As expected, iteration on the tree is obtained by an inorder traversal. This means we traverse the left-subtree first since it contains the smallest elements, then it's the turn of the node's value itself and finally we process the biggest elements by travesing the right-subtree.

h3. Bounded view

bc. /** Creates a ranged projection of this collection. Any mutations in the
 *  ranged projection will update this collection and vice versa.  Note: keys
 *  are not garuanteed to be consistent between this collection and the projection.
 *  This is the case for buffers where indexing is relative to the projection.
 *
 *  @param from  The lower-bound (inclusive) of the ranged projection.
 *               <code>None</code> if there is no lower bound.
 *  @param until The upper-bound (exclusive) of the ranged projection.
 *               <code>None</code> if there is no upper bound.
 */
def rangeImpl(from: Option[K], until: Option[K]): This

rangeImpl is a mandatory method in order to conforms to SortedSetLike trait. Adopted solution to do this is to bound tree iteration itself instead of working on the undelying AVL tree. Indeed since in AVL all elements in left sub-tree are lower than node's element witch is itself lower to all elements in right sub-tree we can simply stop the left or right iteration once we detect we are off bounds. Here is the code :

bc. /**
 * Returns a bounded stream of elements in the tree
 */
def toStream[A](tree: AVLTree[A], isLeftAcceptable: A => Boolean, isRightAcceptable: A => Boolean): Stream[A] = tree match {
  case Leaf => Stream.empty
  case Node(a, left, right) => if (isLeftAcceptable(a)) {
    if (isRightAcceptable(a))
      toStream(left, isLeftAcceptable, isRightAcceptable) ++ Stream(a) ++ toStream(right, isLeftAcceptable, isRightAcceptable)
    else
      toStream(left, isLeftAcceptable, isRightAcceptable)
  } else if (isRightAcceptable(a)) {
    toStream(right, isLeftAcceptable, isRightAcceptable)
  } else {
    Stream.empty
  }
} 

bc. // View secondary constructor
private def this(base: Option[TreeSet[A]], from: Option[A], until: Option[A])(implicit ordering: Ordering[A]) {
  this()
  this.base = base
  this.from = from
  this.until = until
}

bc. override def rangeImpl(from: Option[A], until: Option[A]): TreeSet[A] = new TreeSet(Some(this), from, until)

So rangeImpl returns a proxy of the initial tree, every operation is in fact pocessed on original TreeSet. The only specific data is the tuple of bounds 'from' and 'until'.

h3. Size method optimisation

In order to improve performances, some base method overriding is required. This is the case for 'size', indeed, base implementation  consumes an iterator to compute the size. This makes this method inefficient since complexity in time is O(n). A basic solution is to store size and update the count when insertion or removal occurs. However this optimisation cannot apply when the object is a bounded projection and could be a point of improvement.

h3. Clone method optimisation

clone is also a good candidate for optimisation. Base implementation creates an empty set and iterates over the inital one to add each element to the clone. So here again there is an O(n) complexity in time. To resolve this, we take advantage of the *immutable* nature of the underlying AVL tree. Thanks to the immutability of the avl, we can simply share it among the original set and his clone. Good point for immutable data structures! Complexity in times becomes constant.

h2. Performance quick benchmark

!https://github.com/lpereir4/t4147/raw/master/src/test/resources/output3.png!

h2. Usefull documentation

* "http://www.scala-lang.org/docu/files/collections-api/collections.html":http://www.scala-lang.org/docu/files/collections-api/collections.html
* "http://www.scala-lang.org/docu/files/collections-api/collections-impl.html":http://www.scala-lang.org/docu/files/collections-api/collections-impl.html
* "http://www.artima.com/scalazine/articles/scala_collections_architecture.html":http://www.artima.com/scalazine/articles/scala_collections_architecture.html
